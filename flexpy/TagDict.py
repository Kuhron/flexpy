import os

from xml.etree import ElementTree as ET

from flexpy.FlexPyUtil import (get_tag_class, get_element_info_str, 
    parse_xml_without_namespaces, elstr)
import flexpy.XMLTagMap as xml_tag_map


class TagDict:
    """A class which organizes the FLEx database's XML elements for easier location
    by XML tag, `guid` (an identifier generated by FLEx), and other attributes
    """
    def __init__(
            self, 
            by_tag=None, 
            by_tag_and_guid=None, 
            by_guid=None, 
            by_owner_guid=None,
            roots=None,
            object_by_element=None,
    ):
        self.by_tag = by_tag if by_tag is not None else {}
        self.by_tag_and_guid = by_tag_and_guid if by_tag_and_guid is not None else {}
        self.by_guid = by_guid if by_guid is not None else {}
        self.by_owner_guid = by_owner_guid if by_owner_guid is not None else {}
        self.roots = roots if roots is not None else []
        self.object_by_element = object_by_element if object_by_element is not None else {}
        self.dependency_dict = self.create_dependency_dict()

    @staticmethod
    def from_project_dir_and_name(project_dir, project_name):
        """Creats a TagDict for a FLEx project

        :param project_dir: the directory where the FLEx project is found
        :param project_name: the FLEx project's name (there should be a folder in `project_dir`
            which is named this)
        """
        flex_dir = os.path.join(project_dir, f"{project_name}")
        fp = os.path.join(flex_dir, f"{project_name}.fwdata")
        # print("getting TagDict from FLEx project {} at {}".format(project_name, fp))
        return TagDict.from_fwdata_file(fp)

    @staticmethod
    def from_all_projects_in_dir(project_dir):
        """Creates a TagDict which includes all tags found in any project in the `project_dir`.

        :param project_dir: the directory where the FLEx projects are found.
            This function assumes every subdirectory is a FLEx project.
            To avoid this, use `TagDict.from_project_dir_and_name()` for each desired
            subdirectory.
        """
        subdirs = [f.name for f in os.scandir(project_dir) if f.is_dir()]
        print(subdirs)
        flex_dirs = [os.path.join(project_dir, f"{subdir}") for subdir in subdirs]
        fps = [os.path.join(flex_dir, f"{subdir}.fwdata") for flex_dir, subdir in zip(flex_dirs, subdirs)]
        return TagDict.from_fwdata_files(fps)

    @staticmethod
    def from_fwdata_file(fp):
        """Creates a TagDict directly from a filepath to FLEx data (.fwdata)
        """
        assert type(fp) is str
        return TagDict.from_fwdata_files([fp])

    @staticmethod
    def from_fwdata_files(fps):
        """Creates a TagDict directly from a list of filepaths to FLEx data (.fwdata)
        """
        assert type(fps) is list
        roots = []
        for fp in fps:
            root = parse_xml_without_namespaces(fp)
            assert "fp" not in root.attrib
            root.attrib["fp"] = fp
            roots.append(root)
        return TagDict.from_roots(roots)

    @staticmethod
    def from_root(root):
        """Creates a TagDict directly from an xml.etree root object
        """
        return TagDict.from_roots([root])

    @staticmethod
    def from_roots(roots):
        """Creates a TagDict directly from a list of xml.etree root objects
        """
        # all elements in the XML
        # the dictionary is keyed by "class" attribute (e.g. "LexEntry") and then by FLEX's identifier for each object
        print("creating TagDict from roots")

        all_elements = []
        for root in roots:
            children_of_this_root = list(root)
            children_tags = set(x.tag for x in children_of_this_root)
            assert children_tags == {"rt"}, "unhandled tag types in element tree: {}, expected only \"rt\"".format(sorted(children_tags))
            all_elements_under_this_root = xml_tag_map.get_all_children_recursive(root)
            for el in all_elements_under_this_root:
                if "fp" in el.attrib:
                    assert el.attrib["fp"] == root.attrib["fp"]
                else:
                    el.attrib["fp"] = root.attrib["fp"]
            all_elements += all_elements_under_this_root

        by_tag = {}
        by_tag_and_guid = {}
        by_guid = {}
        by_owner_guid = {}
        all_rt_attrib_keys = set()
        tags_allowing_duplicate_guids = ["CmSemanticDomain", "CmAnthroItem"]  # things that FLEx puts in all projects
        for el in all_elements:
            assert type(el) is ET.Element, el
            tag_key = xml_tag_map.get_tag_key_from_element(el, by_guid)
            if tag_key is None:
                print(f"Warning: got no tag key for element {elstr(el)}; ignoring it")
            elif el.tag == "rt":
                all_rt_attrib_keys |= set(el.attrib.keys())
                guid = el.attrib["guid"]  # rts should all have a guid
                guid_collision_allowed = False

                if tag_key not in by_tag:
                    by_tag[tag_key] = []
                by_tag[tag_key].append(el)

                if tag_key not in by_tag_and_guid:
                    by_tag_and_guid[tag_key] = {}

                if guid not in by_tag_and_guid[tag_key]:
                    by_tag_and_guid[tag_key][guid] = []
                    # allow multiple elements with same tag and guid, e.g. duplicate default elements from multiple FLEx projects
                by_tag_and_guid[tag_key][guid].append(el)

                if guid not in by_guid:
                    by_guid[guid] = []
                by_guid[guid].append(el)

                try:
                    owner_guid = el.attrib["ownerguid"]  # only some have owners
                    if owner_guid not in by_owner_guid:
                        by_owner_guid[owner_guid] = []
                    by_owner_guid[owner_guid].append(el)
                except KeyError:
                    # has no owner
                    pass

            elif el.tag == "objsur":
                # only a surrogate for some rt element present elsewhere, ignore it
                # these only exist to show ownership/reference relationships
                pass

            else:
                # only rts should have guid and ownerguid
                assert "guid" not in el.attrib, "element has a guid but shouldn't: {}, guid={}".format(el, el.attrib["guid"])
                assert "ownerguid" not in el.attrib, "element has an ownerguid but shouldn't: {}, ownerguid={}".format(el, el.attrib["ownerguid"])

                if tag_key not in by_tag:
                    by_tag[tag_key] = []
                by_tag[tag_key].append(el)

        expected_all_rt_attrib_keys = {"class", "guid", "ownerguid", "fp"}  # I added fp myself, telling which project it came from
        assert all_rt_attrib_keys == expected_all_rt_attrib_keys, "rt elements have attributes {}, expected {}".format(all_rt_attrib_keys, expected_all_rt_attrib_keys)

        return TagDict(
            by_tag=by_tag,
            by_tag_and_guid=by_tag_and_guid,
            by_guid=by_guid,
            by_owner_guid=by_owner_guid,
            roots=roots,  # store for later use e.g. printing dependencies of elements
        )

    def __getitem__(self, index):
        try:
            return self.by_guid[index]
        except KeyError:
            try:
                # try giving the class-specific dict
                return self.by_tag_and_guid[index]
            except KeyError:
                pass  # don't want "another exception was raised while handling"

        # if got here, we had both KeyErrors occur
        # do actually want to raise in this case
        raise KeyError("key {} is neither a class name nor a guid".format(index))
    
    def get(self, index, backup_value=None):
        try:
            return self[index]
        except KeyError:
            return backup_value

    def get_single_element_by_guid(self, guid):
        referents = self.by_guid.get(guid)
        if referents is None:
            return None
        elif len(referents) == 0:
            return None
        elif len(referents) > 1:
            raise Exception(f"guid {guid} has more than one referent")
        else:
            referent, = referents
            return referent

    def get_single_element_by_tag_and_guid(self, tag_key, guid):
        try:
            dict_with_tag_key = self.by_tag_and_guid[tag_key]
        except KeyError:
            raise KeyError(f"TagDict has no tag key of '{tag_key}'")
        
        referents = self.by_tag_and_guid[tag_key].get(guid)
        if referents is None:
            return None
        elif len(referents) == 0:
            return None
        elif len(referents) > 1:
            raise Exception(f"guid {guid} has more than one referent")
        else:
            referent, = referents
            return referent

    def keys(self):
        return self.by_guid.keys()

    def values(self):
        return self.by_guid.values()

    def items(self):
        return self.by_guid.items()

    def all_elements(self):
        res = []
        for guid, els_with_guid in self.by_guid.items():
            res += els_with_guid
        return res

    def get_by_owner_guid(self, guid):
        return self.by_owner_guid.get(guid, [])

    def get_all_rts(self):
        return self.by_guid.values()

    def get_all_elements(self):
        elements = []
        for tag, lst in self.by_tag.items():
            elements += lst
        return elements

    def create_dependency_dict(self):
        return xml_tag_map.create_dependency_dict_from_multiple_roots(self.roots, self.by_guid)

    def print_dependency_dict(self):
        d = self.create_dependency_dict()
        xml_tag_map.print_dependency_dict(d)

    def get_python_object_from_element(self, el, parent_el=None):
        # print(f"getting python object from element {elstr(el)} and parent_el {elstr(parent_el)}")
        assert type(el) is ET.Element, "invalid element: {}".format(el)
        if parent_el is not None:
            assert type(parent_el) is ET.Element, "invalid parent element: {}".format(parent_el)

        el_info = get_element_info_str(el)
        if el.tag == "objsur":
            # resolve to the referent
            reference_guid = el.attrib["guid"]
            referents = self[reference_guid]
            if len(referents) == 0:
                raise RuntimeError(f"no element found from objsur referring to guid {reference_guid} in element\n{el_info}")
            elif len(referents) > 1:
                raise RuntimeError(f"multiple elements found from objsur referring to guid {reference_guid} in element\n{el_info}")
            else:
                referent, = referents
                assert referent.tag != "objsur", "objsur {} refers to another objsur {}".format(el, referent)
                return self.get_python_object_from_element(referent, parent_el=parent_el)
        try:
            # fetch already-created object
            return self.object_by_element[el]
        except KeyError:
            # create new object
            # print("creating new python object for {}".format(el))
            class_object = get_tag_class(el)
            # initialize it
            return class_object(el, parent_el=parent_el, tag_dict=self)

    # def fill_out_objects(self):
    #     # this will try to do all of them, and can encounter recursion errors
    #     for el in self.get_all_elements():
    #         python_object = self.get_python_object_from_element(el)
    #         self.object_by_element[el] = python_object
    #         print("successfully filled out object for element {}".format(el))
    #     print("done filling out elements")